% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rem.R
\name{rem_covars}
\alias{rem_covars}
\title{Convert covariate factors to logical vector}
\usage{
rem_covars(df_covars, ids = NULL, covar_v = NULL, covar_m = NULL,
  covar_t = "attr", idcol = NULL, ...)
}
\arguments{
\item{df_covars}{Dataframe or matrix which contains covariate information. This can either be
a dataframe where columns specify sociodemographic variables such as age, gender, etc.
or it can be a matrix which specifies co-location.}

\item{ids}{Filter for specific ids in df_covars. If \code{ids=NULL}, all
entries of the \code{df_covars} will be retrieved. If \code{idcol=NULL}, assumes that ids match
row index; otherwise extra column with ids has to be specified in param \code{idcol}.}

\item{covar_v}{Vector of length two. First entry specifies name of attribute to retrieve.
This has to correspond to the column name in df_covars. Second entry specifies reference value set
to \code{TRUE}. If only first entry is provided original attribute values are
returned and not a logical vector. Returns logical *vector*}

\item{covar_m}{Vector of length two or three. First entry specifies name of the attribute to
retrieve (e.g. gender). Second entry specifies comparison to be applied such as usually comparison
operators "==", "!=" or operators for numeric values such as "-|+".
Returns n x n *matrix*.}

\item{covar_t}{String. Either of c("attr" | "co.loc" | "rr"). Indicating type of covariate data.
Usually this is either a vector or a matrix of data attributes. However, there are further two
special types, namely the colocation matrix (covar_t="co.loc") and the round robin formats
(covar_t="rr"). Default value is "attr".}

\item{idcol}{Name or index of the column which should be used to filter for \code{ids}. Default
is \code{NULL} meaning that provided \code{ids} correspond to the row index.}
}
\value{
either logical vector or data matrix for given attribute containing difference between two
 node values.

Matrix
}
\description{
Converts a factor (or character) vector into a logical vector (or matrix)
 where the reference category is set to \code{TRUE} and all other levels to \code{FALSE}. The
 resulting logical vector (or matrix) is used as covariate parameter in the \code{relevent::rem.dyad()}
 function.

 There are two modes: either retrieves a logical vector or a n x n difference/similarity matix of
 node attributes.
}
\details{
The order of the values for the covariate vector will be identical to the order in the
 df_covar dataframe. It is important that the IDs of the nodes has an ascending order since
 \code{\link[relevent]{rem.dyad}} expects its nodes to be ordered from 1..n in ascending order as well.
 When converting a sociometric data frame to an edge list to be used with relevent package, the
 default behavior takes care that original values are replaced in ascending order starting with
 1..n.

 \code{covar_m} retrieves a (difference) matrix from covariate attributes. \code{covar_m=c("Gender", "==", "Men")}
 for example retrieves a matrix where men-men dyad are set to 1 and all other combinations of
 dyads is set to 0. The same code without a reference category specified \code{covar_m=c("Gender", "==")}
 returns a matrix where homophilios ties (men-men or women-women) is set to 1 and all others 0.
}
\examples{

#Retrieve a numeric vector of the column "Tenure" in dataframe df.attr for badge ids 2,5,7,9
tenure <- rem_covars(df.attr, ids=c(2,5,7,9), covar_v=c("Tenure"))

#Retrieve a logical vector of "Role" Column, now with "Team leader" as reference category and set to TRUE
isLeader <-  rem_covars(df.attr, ids=ub, covar_v=c("Role", "Team leader"))

#Retrieve a n x n matrix of Gender (where n depends on the length of badge IDs in "ub") of "Gender", indicating
#TRUE if two badges have the same "Gender" or FALSE otherwise.
sameSex <- rem_covars(df.attr, ids=ub, covar_m=c("Gender", "=="))

#Retrieve a n x n matrix of Gender where men-men ties are set to 1 and all others to 0
rem_covars(df.attr, covar_m=c("Gender", "==", "Men"))

#Retrieve difference matrix of factor roles; if Role is factor, uses underlying numeric
#representation to construct difference.
rem_covars(df.attr, covar_m=c("Role", "-"))

}
\seealso{
\code{rem_edge_list},
}
